
.. title :: Equilibration

*************
Equilibration
*************

All molecular dynamics simulations depend very strongly on using the correct ensemble. Without it, the simulation may diverge from its target and fail to tell you anything useful. Gentle equilibration is necessary to avoid falling into metastable states which cannot be escaped in the timescale of your simulation. It is particularly important to avoid this outcome when simulating objects that have a combination of soft and stiff fluctuations -- e.g. proteins -- or complicated conformational dynamics. 

Molecular dynamics tutorials often emphasize the importance of using the correct ensemble. Most starting configurations contain the user's best guess at the physical structure of a small system. However, this best guess is usually different than its equilibrated state. One major benefit of using a first-principles molecular dynamics simulation is that the integrator will help guide an unfavorable configuration towards equilibrium. Here we will describe how automacs can implement an arbitrary serires of ensemble changes in order to guide your starting structure to equilibrium and eventual production simulations.

Minimization
------------

Minimize early and minimize often. Most starting configurations only glancingly resemble their final, equilibrated state. Energy minimization is almost always required before running molecular dynamics because it carefully reduces the number of unfavorable interactions e.g. steric clashes and abnormal bond lengths which are present in your system. 

We perform minimization in several places in each procedure, each time making use of the :meth:`minimize <amx.procedures.common.minimize>` function reproduced below.

.. code-block :: python

	@narrate
	def minimize(name,method='steep'):

		"""
		minimize(name,method='steep')
		Standard minimization procedure.
		"""

		gmx('grompp',base='em-%s-%s'%(name,method),top=name,structure=name,
			log='grompp-%s-%s'%(name,method),mdp='input-em-%s-in'%method,skip=True)
		assert os.path.isfile(wordspace['step']+'em-%s-%s.tpr'%(name,method))
		gmx('mdrun',base='em-%s-%s'%(name,method),log='mdrun-%s-%s'%(name,method))
		filecopy(wordspace['step']+'em-'+'%s-%s.gro'%(name,method),
			wordspace['step']+'%s-minimized.gro'%name)
		checkpoint()

For each dynamics or minimization run, GROMACS requires an input ``tpr`` file generated by the ``grompp`` utility. The minimize function creates this binary input file and sends it to the integrator (``mdrun``) using a standardized naming scheme. The naming scheme looks for the integrator parameters in a file named ``input-em-<method>-in.mdp`` which is generated by :meth:`write_mdp <amx.base.mdp.write_mdp>` described :ref:`below <mdp_parameters>`. This allows the user to apply different minimization schemes depending on the situation. 

For most purposes, a standard steepest-descent minimization is sufficient. Some calculations, such as normal-mode analyses, require more intensive minimizations.

Equilibration in stages
-----------------------

Like the minimization function described above, equilibration procedes in pairs of preprocessor and ``mdrun`` calls. Users can implement an arbitrarily long sequence of ensemble changes using the :meth:`equilibrate <amx.procedures.common.equilibrate>` function reproduced below.

.. code-block :: python

	@narrate
	def equilibrate(groups=None,structure='system'):

		"""
		equilibrate()
		Standard equilibration procedure.
		"""

		#---sequential equilibration stages
		seq = wordspace['equilibration'].split(',')
		for eqnum,name in enumerate(seq):
			if not equilibrate_check(name):
				gmx('grompp',base='md-%s'%name,top='system',
					structure=structure if eqnum == 0 else 'md-%s'%seq[eqnum-1],
					log='grompp-%s'%name,mdp='input-md-%s-eq-in'%name,
					flag=('' if not groups else '-n %s'%groups)+' -maxwarn 10')
				gmx('mdrun',base='md-%s'%name,log='mdrun-%s'%name,skip=True)
				assert os.path.isfile(wordspace['step']+'md-%s.gro'%name)
				checkpoint()

		#---first part of the equilibration/production run
		name = 'md.part0001'
		if not equilibrate_check(name):
			gmx('grompp',base=name,top='system',
				structure='md-%s'%seq[-1],
				log='grompp-0001',mdp='input-md-in',
				flag='' if not groups else '-n %s'%groups)
			gmx('mdrun',base=name,log='mdrun-0001')
			#---we don't assert that the file exists here because the user might kill it and upload
			checkpoint()

In contrast to the minimization function, this function can run several dynamics runs in sequence. The user tells the integrator which parameter files to use by setting a comma-delimited string called ``equilibrate`` in the settings block. The names in the resulting list should refer to ``mdp`` parameter files generated by the :meth:`write_mdp <amx.base.mdp.write_mdp>` function. As with the minimization function, these files should be named ``input-md-<name>-in.mdp``. Every time the preprocessor (``grompp``) interprets one of these parameter files, it also stores a copy according to the name of the equilibration step. This copy will include any defaults absent from the input file which GROMACS fills in.

Every equilibration procedure concludes with a production run based on an input file which must be called ``input-md-in.mdp``. The production run commences the ``md.part0001`` :ref:`naming scheme <file_names>`. This makes it easy for analysis codes to locate and organize large sets of production runs.

.. _mdp_parameters:

Parameters
----------

A series of ensemble changes requires a large set of integrator parameters organized into ``mdp`` files. In most cases, however, these individual files resemble each other, differing only slightly between ensembles. Radically changing the integrator parameters is dangerous because it is more likely to produce unfavorable interactions. The most common examples of a ensemble changes include "turning on" a thermodynamic coupling algorithm (e.g. pressure coupling which allows volume to change) or modifying the timestep of the integrator. In some complicated cases, the equilibrate function is used to construct a system with very particular constraints (see the lipid vacuum-packing procedure for a complete example). But otherwise, ensemble changes should be minor.

.. warning ::

	link to vacuum-packer above

Ensembles are defined in ``amx/procedures/parameters.py`` which contains a large, nested dictionary of rules. Users who wish to design custom equilibration procedures using our custom syntax should copy this file to ``inputs/parameters.py`` which always overrides the default values. In this section, we will describe the custom syntax which we have designed to improve readability and avoid repetition. 

The settings block in each parent script may contain a variable called ``mdp_specs``. This variable should consist of a pythonic dictionary. The keys represent the names of the ``mdp`` files we wish to generate. The corresponding values contain a list of constraints which modify the master dictionary of parameters defined in the ``mdpdefs`` dictionary in the ``parameters.py`` file. See the :ref:`customizations <mdp_customizations>` section below for an example. The ``write_mdp`` function will process each element of the ``mdp_specs`` dictionary to produce a new ``mdp`` file. Each time this happens, the entire ``mdpdefs`` dictionary must be "pruned" to produce a consistent set of parameters. Let's walk through how this happens.

A single protected key ``mdp_specs`` dictionary called ``group`` specifies the top-level sub-dictionary in ``mdpdefs`` which we will use. This key is almost always set to either ``'group':'aamd'`` or ``'group':'cgmd'`` so that the ``mdpdefs`` dictionary can hold instructions for both atomistic and coarse-grained simulations. After the ``write_mdp`` function pops the ``group`` value, we can only use parameters defined in the corresponding sub-dictionary. 

.. note ::

	This sounds complicated. It's not. We define all ``mdp`` parameters in a dictionary of dictionaries. Each simulation chooses one to use, and excludes the others using the ``group`` key. 

After whittling the ``mdpdefs`` dictionary down by a single level, the ``write_mdp`` function will construct an ``mdp`` file from the defaults and then modify it according to the constraints in the values of ``mdp_specs``.

Defaults
^^^^^^^^

Our current set of parameters is found in another nested dictionary which contains a protected key called ``defaults``. This key points to another dictionary which maps a parameter category (e.g. potential or temperature) to a specific grouping of these parameters. For example, some users may need to decide between using a legacy cutoff scheme or the newer Verlet method. They can divide these parameters into groupings and set one to be the default by including e.g. ``'potential':'verlet'`` in the defaults dictionary. 

For parameters that do not need multiple groupings, you can set the value in ``defaults`` to ``None``. If a particular category name is mapped to ``None`` then the parser will expect to find a sub-dictionary with that category name at the current level. These parameters can be further customized. It's not necessary to define specific groupings of defaults -- one is sufficient for most purposes.

Each new ``mdp`` file consists of all parameter category groupings listed in the defaults dictionary. If the grouping has multiple options, they are specified at the next level in the dictionary. All parameters requested by the defaults dictionary are written together in the final ``mdp`` file. This scheme is best illustrated with a minimal working example from ``parameters.py``.

.. code-block :: python	

	mdpdefs = {
		#---MDP settings group for atomistic CHARMM simulations
		#---the top level of mdpdefs is specified by the "group" key in mdp_specs
		'aamd':{
			#---defaults for distinct categories of parameters (use None if only one)
			'defaults':{
				'potential':'verlet',
				'couple':None,
				},
			#---category specifications (with sub-dictionaries if there are multiple names)
			'potential':{
				'original':{
					},
				'verlet':{
					'cutoff-scheme':'verlet',
					'coulombtype':'PME',
					'fourierspacing':0.1125,
					'rcoulomb':0.9,
					'rlist':0.9,
					'rvdw':0.9,
					},
				},
			'couple':{
				'tcoupl':'V-rescale',
				'tc_grps':'Protein Non-Protein',
				'tau_t':'0.1 0.1',
				'ref_t':'300 300',
				'pcoupl':'Parrinello-Rahman',
				'pcoupltype':'isotropic',
				'tau_p':2.0,
				'ref_p':1.0,
				'compressibility':'4.5e-5',
				},
			#---more categories may be continue here ...
			},
		},
	}

The ``write_mdp`` function processes the example above as follows. First, it removes ``'group':'aamd'`` from the mdp_specs dictionary (not shown). Then, it processes each item in ``'defaults'``. When it tries to process the ``'potential'`` key, it finds two sub-dictionaries (given by ``'original'`` and ``'verlet'``). It selects ``'verlet'`` according to the ``defaults`` dictionary. The ``'couple'`` settings require no such choice. Instead, ``'couple'`` is mapped to ``None`` in ``defaults`` and the ``couple`` sub-dictionary has one set of parameters at the top-level.

.. _mdp_customizations:

Customizations
^^^^^^^^^^^^^^

Recall that we request a set of ``mdp`` files using the ``mdp_specs`` variable in the settings block of the parent script. This variable is a dictionary of desired ``mdp`` file names mapped to lists of constraints. An empty list will create an ``mdp`` file with default values according to the rules described above. To make ``mdp`` files with variations from the default, we can add two kinds of constraints. Let's demonstrate this with an example.

.. code-block :: python

	mdp_specs = {
		'group':'aamd',
		'input-em-steep-in.mdp':['minimize'],
		'input-em-cg-in.mdp':['minimize',{'integrator':'cg'}],
		'input-md-vacuum-pack1-eq-in.mdp':['vacuum-packing',{'nsteps':10000}],
		'input-md-vacuum-pack2-eq-in.mdp':['vacuum-packing',{'ref_p':'100.0 1.0'}],
		'input-md-vacuum-pack3-eq-in.mdp':['vacuum-packing'],
		'input-md-npt-bilayer-eq-in.mdp':['npt-bilayer-simple',],
		'input-md-in.mdp':['npt-bilayer'],
		}

The simplest constraint is a dictionary that overrides the default parameters. For example, if you wish to set a custom number of time steps in a particular run, you can include ``{'nsteps':10000}`` to override the ``nsteps`` parameter. The GROMACS manual contains a `complete list of these parameters <http://manual.gromacs.org/online/mdp_opt.html>`_. You can populate the constraints list with as many dictionaries as you want, but be warned that they will be processed in sequence.

Users may also point to custom parameter sets by including their names in the constraints list. The name should point to a dictionary that is found at the same level as ``defaults`` in ``mdpdefs``. Like the ``defaults`` dictionary, the custom dictionary can refer to groupings of parameters at the same level by name e.g. ``'potential':'verlet'``. However, they can also contain a sub-dictionary with custom overrides for a particular category. In the example ``mdp_specs`` above, a custom ``minimize`` dictionary in ``mdpdefs`` tells automacs how to prepare a parameter file for minimization procedures. If you inspect the ``parameters.py`` code, you can see how these parameters might override the defaults.

.. warning ::

	Look. The whole thing can be summed up as follows. Chop down the main dictionary by "group". Then for every string in the constraints list (add "defaults" if empty), take the key-value pairs for the dictionary with that name at the top level. If the value is a string, try to look it up in the main dictionary as a nested double-key. If that fails, just use the key-value pair directly in the MDP file. If the value is None, just look-up the single-key value from the top level.

The example ``mdp_specs`` described above demonstrates the utility of this bookkeeping scheme. If you wish to generate many similar parameter files during an elaborate equilibration routine, you only need to add additional entries to ``mdp_specs``.

Ensemble or integrator changes during production
------------------------------------------------

While most ensemble changes occur during the construction and equilibration of a new simulation, it is often useful to change the ensemble for a completed or already-running simulation. For example, older simulations can be continued under newer versions of GROMACS by regenerating new run input files. This feature is built-in to automacs via the ``amx/procedures/scripts/script-restart.py``. Users can research from a preexisting simulation stored in ``inputs`` by running ``make program restart`` and customizing the resulting parent script found in ``script-restart.py``. This script has options for continuing a simulation from "scratch" (that is, the structure and topology onl) or from a checkpoint file, which often makes it possible to do a binary-reproducible simulation. The automacs restart procedure covers most of the functions described in the GROMACS manual entry on `continuation <http://www.gromacs.org/Documentation/How-tos/Doing_Restarts>`_.
